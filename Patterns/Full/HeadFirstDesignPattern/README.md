# HeadFirstDesignPatternHead First Design Pattern: my notes taken from the book and exercises that I practiced.---Table of contents==========={:toc}## 1 Strategy Pattern### 1 StrategyStrategy defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.### 2 Shared languagePatterns provide a shared language that can maximize the value of your communication with other developers.## 2 Observer Pattern### Design Principles* Identify the aspects of your application that vary and separate them from what stays the same.  * The thing that varies in the Observer Pattern is the state of the Subject and the number and types of Observers. With this pattern, you can vary the objects that are dependent on the state of the Subject, without having to change that Subject. That's called planning ahead.* Program to an interface, not an implementation. * Both the Subject and Observer use interfaces. The Subject keeps track of objects implementing the Observer interface, while the observers register with and get notified by, the Subject interface. This keeps things nice and loosely coupled.* Favor composition over inheritance. * The Observer Pattern uses composition to compose any number of Observers with their Subjects. These relationships aren't set up by some kind of inheritance hierarchy. No, they are set up at runtime by composition.## 3 Factory Pattern### The Factory Method Pattern*The Factory Method Pattern* defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.### Design Principle* *Dependency Inversion Principle*: Depend upon abstractions. Do not depend upon concrete classes.### The Abstract Factory Pattern*The Abstract Factory Pattern* provides an interface for creating families of related or dependent objects without specifying their concrete classes.## 4 Singleton Pattern*The Singleton Pattern* ensures a class has only one instance, and provides a global point of access of it.## 5 Command Pattern*The Command Pattern* encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations. ## 6 Adapter Pattern*The Adapter Pattern* converts the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.*The Façade Pattern* provides a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.## 7 Template Method Pattern*The Template Method Pattern* defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps.*The Template Method Pattern* defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.## 8 Iterator Pattern*The Iterator Pattern* provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.## 9 Composite Pattern*The Composite Pattern* allows you to compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.## 10 State Pattern*The State Pattern* allows an object to alter its behavior when its internal state changes. The object will appear to change its class.## 11 Proxy Pattern*The Proxy Pattern* provides a surrogate or placeholder for another object to control access to it.Use the Proxy Pattern to create a representative object that controls access to another object, which may be remote, expensive to create or in need of securing.## 12 Compound PatternPatterns are often used together and combined within the same design solution. A *compound pattern* combines two or more patterns into a solution that solves a recurring or general problem.## Summary**A Pattern** is a solution to a problem in a context.The *context* is the situation in which the pattern applies. This should be a recurring situation.The *problem* refers to the goal you are trying to achieve in this context, but it also refers to any constraints that occur in the context.The *solution* is what you're after: a general design that anyone can apply which resolves the goal and set of constraints.